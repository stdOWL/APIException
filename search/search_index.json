{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"APIException","text":""},{"location":"#apiexception-standardised-exception-handling-for-fastapi","title":"APIException: Standardised Exception Handling for FastAPI","text":""},{"location":"#quick-installation","title":"\u26a1 Quick Installation","text":"<p>Download the package from PyPI and install it using pip: <pre><code>pip install apiexception\n</code></pre></p> <p></p> <p>Just import the <code>register_exception_handlers</code> function from <code>APIException</code> and call it with your FastAPI app instance to set up global exception handling: <pre><code>from APIException import register_exception_handlers\nfrom fastapi import FastAPI\napp = FastAPI()\nregister_exception_handlers(app=app)\n</code></pre> That\u2019s it \u2014 copy, paste, and you\u2019re good to go. So easy, isn't it? </p> <p>Now all your endpoints will return consistent <code>success</code> and <code>error</code> responses, and your Swagger docs will be beautifully documented. Exception handling will be logged, and unexpected errors will return a clear JSON response instead of FastAPI\u2019s default HTML error page.</p>"},{"location":"#see-it-in-action","title":"\ud83d\udd0d See It in Action!","text":"<pre><code>from fastapi import FastAPI, Path\nfrom APIException import APIException, ExceptionStatus, register_exception_handlers, ResponseModel, APIResponse, BaseExceptionCode\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n# Register exception handlers globally to have the consistent\n# error handling and response structure\nregister_exception_handlers(app=app)\n\n# Create the validation model for your response\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n\n# Define your custom exception codes extending BaseExceptionCode\nclass CustomExceptionCode(BaseExceptionCode):\n    USER_NOT_FOUND = (\"USR-404\", \"User not found.\", \"The user ID does not exist.\")\n    INVALID_API_KEY = (\"API-401\", \"Invalid API key.\", \"Provide a valid API key.\")\n    PERMISSION_DENIED = (\"PERM-403\", \"Permission denied.\", \"Access to this resource is forbidden.\")\n\n\n@app.get(\"/user/{user_id}\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.default()\n)\nasync def user(user_id: int = Path()):\n    if user_id == 1:\n        raise APIException(\n            error_code=CustomExceptionCode.USER_NOT_FOUND,\n            http_status_code=401,\n        )\n    data = UserResponse(id=1, username=\"John Doe\")\n    return ResponseModel[UserResponse](\n        data=data,\n        description=\"User found and returned.\"\n    )\n</code></pre> <p>When you run your FastAPI app and open Swagger UI (<code>/docs</code>), your endpoints will display clean, predictable response schemas like this:</p> <p></p>"},{"location":"#-successful-api-response","title":"- Successful API Response?","text":"<pre><code>{\n  \"data\": {\n    \"id\": 7,\n    \"username\": \"John Doe\"\n  },\n  \"status\": \"SUCCESS\",\n  \"message\": \"Operation completed successfully.\",\n  \"error_code\": null,\n  \"description\": \"User fetched successfully.\"\n}\n</code></pre>"},{"location":"#-error-api-response","title":"- Error API Response?","text":"<p><pre><code>{\n  \"data\": null,\n  \"status\": \"FAIL\",\n  \"message\": \"User not found.\",\n  \"error_code\": \"USR-404\",\n  \"description\": \"The user ID does not exist.\"\n}\n</code></pre> In both cases, the response structure is consistent.</p> <ul> <li>\ud83d\udfe2 200: Success responses are clearly documented with your data model.</li> <li>\ud83d\udd11 401/403: Custom error codes &amp; messages show exactly what clients should expect.</li> <li>\ud83d\udd0d No more guesswork \u2014 your consumers, frontend teams, and testers see exactly how your API behaves for success and error cases.</li> <li>\u2705 Bonus: Even <code>unexpected server-side issues</code> \u2014 like database errors, unhandled exceptions, or third-party failures \u2014 still return a consistent JSON response that follows your ResponseModel schema. No more raw HTML 500 pages! Every error is logged automatically so you always have a clear trail of what went wrong.</li> </ul> <p>This is how APIException helps you build trustable, professional APIs from day one!</p>"},{"location":"#who-should-use-this","title":"\ud83d\udc65 Who should use this?","text":"<p>\u2705 FastAPI developers who want consistent success &amp; error responses. \u2705 Teams building multi-client or external APIs. \u2705 Projects where Swagger/OpenAPI docs must be clear and human-friendly. \u2705 Teams that need extensible error code management.</p> <p>If you\u2019re tired of:</p> <ul> <li> <p>Inconsistent response structures,</p> </li> <li> <p>Confusing Swagger docs,</p> </li> <li> <p>Messy exception handling,</p> </li> <li> <p>Finding yourself while trying to find the exception that isn't logged</p> </li> <li> <p>Backend teams asking \u201cWhat does this endpoint return?\u201d,</p> </li> <li> <p>Frontend teams asking \u201cWhat does this endpoint return in error?\u201d,</p> </li> </ul> <p>then this library is for you.</p>"},{"location":"#why-did-i-build-this","title":"\ud83c\udfaf Why did I build this?","text":"<p>After 4+ years as a FastAPI backend engineer, I\u2019ve seen how crucial a clean, predictable response model is. When your API serves multiple frontends or external clients, having different JSON shapes, missing status info, or undocumented error codes turns maintenance into chaos.</p> <p>So, this library:</p> <p>\u2705 Standardizes all success &amp; error responses, \u2705 Documents them beautifully in Swagger, \u2705 Provides a robust ExceptionCode pattern, \u2705 Adds an optional global fallback for unexpected crashes \u2014 all while keeping FastAPI\u2019s speed.</p>"},{"location":"#core-principles","title":"\u2728 Core Principles","text":"<p>\u2022   \ud83d\udd12 Consistency: Success and error responses always follow the same format.</p> <p>\u2022   \ud83d\udcca Clear Docs: OpenAPI/Swagger stays clean and human-friendly.</p> <p>\u2022   \ud83e\udeb6 Zero Boilerplate: Register once, use everywhere.</p> <p>\u2022   \u26a1 Extensible: Fully customizable error codes &amp; handlers.</p>"},{"location":"#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Ready to integrate? Check out: - \ud83d\ude80 Installation \u2014 How to set up APIException.</p> <ul> <li> <p>\u26a1  Quick Start \u2014 Add it to your project in minutes.</p> </li> <li> <p>\ud83e\udde9 Usage \u2014 Response models, custom codes, and fallback middleware.</p> </li> <li> <p>\ud83d\udcda Advanced \u2014 Swagger integration, logging, debugging.</p> </li> <li> <p>\ud83d\udd17 API Reference \u2014 Full reference docs.</p> </li> </ul>"},{"location":"changelog/","title":"\ud83d\udcdd Changelog","text":"<p>All notable changes to APIException will be documented here. This project uses Semantic Versioning.</p>"},{"location":"changelog/#v0116-2025-07-22","title":"[v0.1.16] 2025-07-22","text":"<p>\u2705 Initial stable version</p> <ul> <li> <p>setup.py has been updated.</p> </li> <li> <p>Documentation has been updated. </p> </li> <li> <p>Readme.md has been updated. </p> </li> </ul>"},{"location":"changelog/#v0115-2025-07-22","title":"[v0.1.15] - 2025-07-22","text":"<ul> <li> <p>setup.py has been updated.</p> </li> <li> <p>Project name has been updated. Instead of <code>APIException</code> we will use <code>apiexception</code> to comply with <code>PEP 625</code>.</p> </li> <li> <p>Documentation has been updated. </p> </li> <li> <p>Readme.md has been updated. </p> </li> </ul>"},{"location":"changelog/#v0114-2025-07-22","title":"[v0.1.14] - 2025-07-22","text":"<ul> <li> <p>setup.py has been updated.</p> </li> <li> <p>Project name has been updated. Instead of <code>APIException</code> we will use <code>apiexception</code> to comply with <code>PEP 625</code>.</p> </li> </ul>"},{"location":"changelog/#v0113-2025-07-21","title":"[v0.1.13] - 2025-07-21","text":"<ul> <li> <p>/examples/fastapi_usage.py has been updated.</p> </li> <li> <p>422 Pydantic error has been fixed in APIResponse.default()</p> </li> <li> <p>Documentation has been updated.</p> </li> <li> <p>Exception Args has been added to the logs.</p> </li> <li> <p>Readme has been updated. New gifs have been added.</p> </li> </ul>"},{"location":"changelog/#0112-2025-07-14","title":"[0.1.12] - 2025-07-14","text":"<ul> <li> <p>Documentation has been added to the project.</p> </li> <li> <p>More examples has been added.</p> </li> <li> <p><code>__all__</code> includes more methods.</p> </li> </ul>"},{"location":"changelog/#0111-2025-07-13","title":"[0.1.11] - 2025-07-13","text":"<p>\u2705 Stable release!</p> <ul> <li> <p>Global exception handlers with fallback middleware</p> </li> <li> <p>APIResponse for clean Swagger documentation</p> </li> <li> <p>Production-ready logging for all exceptions</p> </li> </ul>"},{"location":"changelog/#010-2025-06-25","title":"[0.1.0] - 2025-06-25","text":"<p>\ud83d\ude80 Prototype started!</p> <ul> <li> <p>Project scaffolding</p> </li> <li> <p><code>ResponseModel</code> has been added</p> </li> <li> <p><code>APIException</code> has been added</p> </li> <li> <p>Defined base ideas for standardizing error handling</p> </li> </ul>"},{"location":"installation/","title":"\ud83d\ude80 Installation","text":"<p>Set up APIException in minutes. Install it, plug it in \u2014 and enjoy consistent API responses.</p>"},{"location":"installation/#install-via-pip","title":"\ud83d\udce6 Install via pip","text":"<p><pre><code>pip install apiexception\n</code></pre> This will install the latest stable release directly from PyPI.</p>"},{"location":"installation/#requirements","title":"\u2705 Requirements","text":"<ul> <li>Python 3.6+</li> <li>FastAPI 0.75+</li> </ul>"},{"location":"installation/#quick-check","title":"\u2699\ufe0f Quick Check","text":"<p>After installation, verify it\u2019s working: <pre><code>pip show apiexception\n</code></pre></p> <p></p>"},{"location":"installation/#next-step","title":"\u27a1\ufe0f Next Step","text":"<p>Ready to plug it in? Jump to \u26a1 Quick Start for copy-paste integration examples!</p>"},{"location":"advanced/logging/","title":"\ud83e\udeb5 Logging &amp; Debug","text":"<p>Good exception handling is only half the battle \u2014 logging is what keeps your team sane in production.</p> <p>With APIException, unexpected errors don\u2019t just return a nice JSON response;</p> <p>they\u2019re also automatically logged so you always have a clear trail of what went wrong.</p>"},{"location":"advanced/logging/#how-it-works","title":"\u2705 How It Works","text":"<p>When you use: <pre><code>from APIException import register_exception_handlers\nfrom fastapi import FastAPI\n\napp = FastAPI()\nregister_exception_handlers(\n    app=app,\n    use_fallback_middleware=True\n)\n</code></pre> You get two powerful behaviors:</p> <p>1\ufe0f\u20e3 All handled APIExceptions are logged with: - HTTP status - Exception code - Message - Context &amp; traceback</p> <p>2\ufe0f\u20e3 Unhandled exceptions (like DB errors, 3rd-party failures) are caught by the fallback middleware and: - Return a consistent JSON error response (ISE-500 by default) - The full traceback to your console or logging system</p>"},{"location":"advanced/logging/#example-output","title":"\u2699\ufe0f Example Output","text":"<p>When something unexpected happens, you\u2019ll see logs like:</p> <p></p>"},{"location":"advanced/logging/#tips","title":"\u26a1 Tips","text":"<p>\u2705 Use FastAPI\u2019s native logging module to pipe logs to your file, console, or external log aggregator (ELK, CloudWatch, etc.).</p> <p>\u2705 Combine this with FastAPI middlewares or your own log formatter if you want structured JSON logs.</p> <p>\u2705 For sensitive environments, make sure your logs do not expose user data.</p>"},{"location":"advanced/logging/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Want to see how fallback works? Check out \ud83e\ude93 Fallback Middleware</p> <p>\u2714\ufe0f Need better Swagger docs? Go to \ud83d\udcda Swagger Integration</p> <p>\u2714\ufe0f Haven\u2019t defined custom codes yet? Read \ud83d\uddc2\ufe0f Custom Exception Codes</p>"},{"location":"advanced/swagger/","title":"\ud83d\udcda Swagger Integration","text":"<p>One of the best parts of APIException is how cleanly it integrates with <code>Swagger (OpenAPI)</code>.</p> <p>Your success and error responses get documented with clear, predictable schemas \u2014 so your consumers, frontend teams, and testers know exactly what to expect.</p>"},{"location":"advanced/swagger/#how-it-works","title":"\u2705 How it works","text":"<p>Use the <code>response_model</code> parameter for your success schema, and <code>APIResponse.default()</code> or <code>APIResponse.custom()</code> to document expected error cases.</p>"},{"location":"advanced/swagger/#example-apiresponsedefault","title":"\u2699\ufe0f Example: <code>APIResponse.default()</code>","text":"<p>This documents your success response plus the default errors (400, 401, 403, 404, 422, 500).</p> <pre><code>from APIException import APIResponse, ResponseModel\n@app.get(\"/user\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.default()\n)\n</code></pre> <p>When you open Swagger UI, it will show all the possible success and error cases:</p> <p></p>"},{"location":"advanced/swagger/#example-apiresponsecustom","title":"\u2699\ufe0f Example: <code>APIResponse.custom()</code>","text":"<p>Want more control?</p> <p>Use <code>APIResponse.custom()</code> to add your own specific error codes for each endpoint.</p> <p><pre><code>from APIException import ResponseModel, APIResponse\n@app.get(\"/user\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.custom(\n        (401, CustomExceptionCode.INVALID_API_KEY),\n        (403, CustomExceptionCode.PERMISSION_DENIED)\n    )\n)\n</code></pre> In Swagger UI, your custom error cases will show up clearly alongside your success model:</p> <p></p>"},{"location":"advanced/swagger/#tips","title":"\u26a1 Tips","text":"<p>\u2705 APIResponse.default() is perfect for general endpoints that follow standard error codes.</p> <p>\u2705 APIResponse.custom() gives you precise control for business-specific exceptions.</p> <p>No more incomplete or confusing Swagger docs!</p>"},{"location":"advanced/swagger/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Learn how to log exceptions properly: Check \ud83e\udeb5 Logging &amp; Debug</p> <p>\u2714\ufe0f Not using ResponseModel yet? See \u2705 Response Model</p> <p>\u2714\ufe0f Want to add fallback error handling? See \ud83e\ude93 Fallback Middleware</p>"},{"location":"reference/api/","title":"\ud83d\udd17 API Reference","text":"<p>This page lists the main classes, utilities, and helpers you\u2019ll use when working with APIException in your FastAPI project.</p> <p>Use this as a quick lookup when you want to check arguments, defaults, or core methods.</p>"},{"location":"reference/api/#available-exports","title":"\u2705 Available Exports","text":""},{"location":"reference/api/#responsemodel","title":"ResponseModel","text":"<p>\ud83d\udccc What it is:</p> <p>A generic, strongly-typed Pydantic model that standardizes all API responses.</p> <ul> <li>\u2705 Where to import:</li> </ul> <pre><code>from APIException import ResponseModel\n</code></pre> <ul> <li> <p>\u2705 Key Fields:</p> <p>\u2022   <code>data</code>: your payload</p> <p>\u2022   <code>status</code>: SUCCESS, WARNING, FAIL</p> <p>\u2022   <code>message</code>: short summary</p> <p>\u2022   <code>error_code</code>: only set for failures</p> <p>\u2022   <code>description</code>: extra context for debugging</p> </li> </ul> <p><code>message</code> and <code>status</code> are Required fields and the rest is Optional. </p>"},{"location":"reference/api/#apiexception","title":"APIException","text":"<p>\ud83d\udccc What it is:</p> <p>Your main custom exception class \u2014 use this to raise predictable, documented API errors.</p> <ul> <li>\u2705 Where to import:</li> </ul> <pre><code>from APIException import APIException\n</code></pre> <ul> <li> <p>\u2705 Key Args:</p> <p>\u2022   <code>error_code</code>: your BaseExceptionCode enum</p> <p>\u2022   <code>http_status_code</code>: maps to HTTP status</p> </li> </ul>"},{"location":"reference/api/#baseexceptioncode","title":"BaseExceptionCode","text":"<p>\ud83d\udccc What it is:</p> <p>Base class for defining your custom business exception codes.</p> <ul> <li>\u2705 Where to import:</li> </ul> <pre><code>from APIException import BaseExceptionCode\n</code></pre>"},{"location":"reference/api/#apiresponse","title":"APIResponse","text":"<p>\ud83d\udccc What it is: A helper to document your Swagger/OpenAPI responses easily.</p> <ul> <li> <p>\u2705 Where to import: <pre><code>from APIException import APIResponse\n</code></pre></p> </li> <li> <p>\u2705 Usage:</p> <p>\u2022   <code>APIResponse.default()</code> \u2192 adds standard 400\u2013500 errors.</p> <p>\u2022   <code>APIResponse.custom()</code> \u2192 add your own error codes with status.</p> </li> </ul>"},{"location":"reference/api/#register_exception_handlers","title":"register_exception_handlers","text":"<p>\ud83d\udccc What it is:</p> <p>Sets up global handlers to catch APIException and unexpected errors.</p> <ul> <li> <p>\u2705 Where to import: <pre><code>from APIException import register_exception_handlers\n</code></pre></p> </li> <li> <p>\u2705 Key Options:</p> <p>\u2022   <code>use_response_model</code>: bool (default True) | Return responses using <code>ResponseModel</code>.</p> <p>\u2022   <code>use_fallback_middleware</code>: bool (default True) | Catch unhandled exceptions and return a consistent fallback.</p> </li> </ul>"},{"location":"reference/api/#example","title":"\u26a1 Example","text":"<p>Here\u2019s how a typical setup might look:</p> <pre><code>from APIException import (\n    APIException,\n    BaseExceptionCode,\n    ResponseModel,\n    APIResponse,\n    register_exception_handlers\n)\n</code></pre>"},{"location":"reference/api/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Haven\u2019t seen how to integrate yet? Go to \ud83d\ude80 Installation</p> <p>\u2714\ufe0f Want a quick end-to-end setup? Check out \u26a1 Quick Start</p> <p>\u2714\ufe0f See how to extend this with your own codes: Read \ud83d\uddc2\ufe0f Custom Exception Codes</p>"},{"location":"usage/custom_codes/","title":"\ud83d\uddc2\ufe0f Using Custom Exception Codes","text":"<p>Defining your own business-specific error codes keeps your API predictable, self-documenting, and easy to maintain.</p> <p>The <code>BaseExceptionCode</code> in APIException gives you a simple pattern to organize, reuse, and expand your error codes \u2014 all while keeping them consistent across your endpoints.</p>"},{"location":"usage/custom_codes/#why-use-custom-codes","title":"\u2705 Why Use Custom Codes?","text":"<p>\u2714\ufe0f Consistent error structure for your entire API \u2714\ufe0f Human-readable, unique codes for each failure scenario \u2714\ufe0f Easy for frontend or clients to handle specific cases</p>"},{"location":"usage/custom_codes/#example-define-and-raise","title":"\ud83d\udccc Example: Define and Raise","text":""},{"location":"usage/custom_codes/#define-your-codes","title":"\u2705 Define Your Codes","text":"<p>Create your own class by extending <code>BaseExceptionCode</code> and declare your error codes once:</p> <pre><code>from APIException import BaseExceptionCode\n\nclass CustomExceptionCode(BaseExceptionCode):\n    # Format: KEY = (code, message, description)\n    USER_NOT_FOUND = (\"USR-404\", \"User not found.\", \"The user ID does not exist.\")\n    INVALID_API_KEY = (\"API-401\", \"Invalid API key.\", \"Provide a valid API key.\")\n    PERMISSION_DENIED = (\"PERM-403\", \"Permission denied.\", \"Access to this resource is forbidden.\")\n</code></pre>"},{"location":"usage/custom_codes/#use-them-with-apiexception","title":"\u2705 Use Them with APIException","text":"<p>Raise your custom error with full <code>typing</code>, <code>logging</code>, and <code>standardized</code> response:</p> <p><pre><code>from APIException import APIException\n\nraise APIException(\n    error_code=CustomExceptionCode.PERMISSION_DENIED,\n    http_status_code=403\n)\n</code></pre> In the above example, if we raise the <code>APIException()</code>, the response will look like the below image. </p> <p>And it will automatically log the event. Log format can be seen in the below image.</p> <p></p>"},{"location":"usage/custom_codes/#how-it-looks-in-responses","title":"\ud83c\udff7\ufe0f How It Looks in Responses","text":"<p>\u2714\ufe0f Clear.</p> <p>\u2714\ufe0f Always consistent.</p> <p>\u2714\ufe0f Fully documented in Swagger UI.</p> <p>\u2714\ufe0f Automatically logged.</p>"},{"location":"usage/custom_codes/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Want to handle unexpected errors with a fallback? Read about \ud83e\ude93 Fallback Middleware</p> <p>\u2714\ufe0f Ready to integrate this with your Swagger docs? See \ud83d\udcda Swagger Integration</p> <p>\u2714\ufe0f Learn more about response structure? Check \u2705 Response Model</p>"},{"location":"usage/fallback/","title":"\ud83e\ude93 Fallback Middleware","text":"<p>A global fallback ensures your API always returns a predictable JSON response \u2014 even when something goes wrong that you didn\u2019t catch.</p> <p>When you enable <code>use_fallback_middleware=True</code>, APIException adds an extra middleware layer to handle any unhandled exceptions like database crashes, coding bugs, or third-party failures.</p>"},{"location":"usage/fallback/#why-use-it","title":"\u2705 Why use it?","text":"<ul> <li>No more raw <code>HTML 500 Internal Server Error</code> pages.</li> <li>Logs unexpected errors automatically \u2014 you get stack traces in logs, but your client gets a safe, clear JSON.</li> <li>Keeps your API response consistent no matter what goes wrong.</li> </ul>"},{"location":"usage/fallback/#how-to-enable","title":"\u2699\ufe0f How to enable","text":"<p>When you call <code>register_exception_handlers()</code>, just pass <code>use_fallback_middleware=True</code>.</p> <p><pre><code>from fastapi import FastAPI\nfrom APIException import register_exception_handlers\n\napp = FastAPI()\n\nregister_exception_handlers(\n    app=app,\n    use_fallback_middleware=True\n)\n</code></pre> Simple as that! </p>"},{"location":"usage/fallback/#example-fallback-response","title":"\ud83d\udccc Example fallback response","text":"<p>Imagine your database goes down. Instead of an ugly HTML page, the fallback returns this: <pre><code>{\n  \"data\": null,\n  \"status\": \"FAIL\",\n  \"message\": \"Something went wrong.\",\n  \"error_code\": \"ISE-500\",\n  \"description\": \"An unexpected error occurred. Please try again later.\"\n}\n</code></pre> So frontend team can always handle errors the same way.</p>"},{"location":"usage/fallback/#tips","title":"\u26a1 Tips","text":"<p>\u2705 By default, fallback middleware is enabled (True).</p> <p>\u2705 You can disable it by passing <code>use_fallback_middleware=False</code>.</p> <p>\u2705 Works perfectly alongside your custom APIException raises.</p>"},{"location":"usage/fallback/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Want to integrate this with your Swagger docs? See \ud83d\udcda Swagger Integration</p> <p>\u2714\ufe0f Want to log exceptions in detail? Check \ud83e\udeb5 Logging &amp; Debug</p> <p>\u2714\ufe0f New here? Start with \ud83e\udde9 Response Model</p>"},{"location":"usage/quick_start/","title":"\u26a1 Quick Start","text":"<p>Get up and running with APIException in just a few minutes!</p>"},{"location":"usage/quick_start/#install-the-package","title":"\u2705 Install the Package","text":"<p>If you haven't done it yet, Let's first start by installing APIException from PyPI: <pre><code>pip install apiexception\n</code></pre></p>"},{"location":"usage/quick_start/#register-exception-handlers","title":"\u2705 Register Exception Handlers","text":"<p>Add the register_exception_handlers to your FastAPI app to automatically handle and standardize your responses:</p> <p><pre><code>from APIException import register_exception_handlers\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nregister_exception_handlers(app=app)\n</code></pre> That\u2019s it! Your API now returns consistent success &amp; error responses, and unexpected server errors are automatically logged with a clear JSON output.</p>"},{"location":"usage/quick_start/#example-endpoint","title":"\u2705 Example Endpoint","text":"<p>Here\u2019s a minimal example: <pre><code>from fastapi import FastAPI, Path\nfrom APIException import APIException, ExceptionStatus, register_exception_handlers, ResponseModel, APIResponse, BaseExceptionCode\nfrom pydantic import BaseModel, Field\n\napp = FastAPI()\n\n# Register exception handlers globally to have the consistent\n# error handling and response structure\nregister_exception_handlers(app=app)\n\n# Create the validation model for your response\nclass UserResponse(BaseModel):\n    id: int = Field(..., example=1, description=\"Unique identifier of the user\")\n    username: str = Field(..., example=\"Micheal Alice\", description=\"Username or full name of the user\")\n\n\n# Define your custom exception codes extending BaseExceptionCode\nclass CustomExceptionCode(BaseExceptionCode):\n    USER_NOT_FOUND = (\"USR-404\", \"User not found.\", \"The user ID does not exist.\")\n    INVALID_API_KEY = (\"API-401\", \"Invalid API key.\", \"Provide a valid API key.\")\n    PERMISSION_DENIED = (\"PERM-403\", \"Permission denied.\", \"Access to this resource is forbidden.\")\n\n\n@app.get(\"/user/{user_id}\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.default()\n)\nasync def user(user_id: int = Path()):\n    if user_id == 1:\n        raise APIException(\n            error_code=CustomExceptionCode.USER_NOT_FOUND,\n            http_status_code=401,\n        )\n    data = UserResponse(id=1, username=\"John Doe\")\n    return ResponseModel[UserResponse](\n        data=data,\n        description=\"User found and returned.\"\n    )\n</code></pre> The below gif demonstrates what actually the example code does.</p> <p></p> <p><code>Swagger UI</code> will be well structured. </p>"},{"location":"usage/quick_start/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Want to learn how to customize your responses? Check out \ud83e\udde9 Usage for response models, custom exception codes, and fallback middleware.</p> <p>\u2714\ufe0f Need to fine-tune Swagger docs? See \ud83d\udcda Advanced for better documentation &amp; logging tips.</p>"},{"location":"usage/response_model/","title":"\ud83e\udde9 Using <code>ResponseModel</code>","text":"<p>A clean, predictable response structure is the heart of a stable API.</p> <p>The <code>ResponseModel</code> in APIException makes sure every success and error response always has the same JSON format \u2014 easy to document, easy to parse, and friendly for frontend teams.</p> <p></p>"},{"location":"usage/response_model/#how-it-works","title":"\u2705 How It Works","text":"<p>Every API response includes:</p> <ul> <li><code>data</code>: your actual payload  </li> <li><code>status</code>: one of <code>SUCCESS</code>, <code>WARNING</code>, <code>FAIL</code> </li> <li><code>message</code>: a short summary of the outcome  </li> <li><code>error_code</code>: only filled if there\u2019s an error  </li> <li><code>description</code>: extra context for debugging</li> </ul> <p>\ud83d\udc49 How to interpret:</p> <ul> <li> <p>If <code>data</code> is populated and <code>error_code</code> is null \u2192 treat as success</p> </li> <li> <p>If <code>error_code</code> is filled \u2192 treat as fail</p> </li> <li> <p>Your frontend can always rely on the <code>status</code> field to drive logic</p> </li> </ul>"},{"location":"usage/response_model/#example","title":"\ud83d\udccc Example","text":""},{"location":"usage/response_model/#import-and-use","title":"\u2705 Import and Use","text":"<pre><code>from fastapi import FastAPI\nfrom APIException import (\n    ResponseModel,\n    APIResponse,\n    APIException,\n    ExceptionStatus,\n    BaseExceptionCode\n)\nfrom pydantic import BaseModel, Field\n\napp = FastAPI()\n\n'''\nCustom Exception Class that you can define in your code to make the backend responses look more standardized.\nJust extend the `BaseExceptionCode` and use it. \n'''\nclass CustomExceptionCode(BaseExceptionCode):\n    USER_NOT_FOUND = (\"USR-404\", \"User not found.\", \"The user ID does not exist.\")\n    INVALID_API_KEY = (\"API-401\", \"Invalid API key.\", \"Provide a valid API key.\")\n    PERMISSION_DENIED = (\"PERM-403\", \"Permission denied.\", \"Access to this resource is forbidden.\")\n    VALIDATION_ERROR = (\"VAL-422\", \"Validation Error\", \"Input validation failed.\")\n    TYPE_ERROR = (\"TYPE-400\", \"Type error.\", \"A type mismatch occurred in the request.\")  # &lt;- EKLEND\u0130\n\n\n\nclass ApiKeyModel(BaseModel):\n    api_key: str = Field(..., example=\"b2013852-1798-45fc-9bff-4b6916290f5b\", description=\"Api Key.\")\n\n\n@app.get(\n    \"/apikey\",\n    response_model=ResponseModel[ApiKeyModel],\n    responses=APIResponse.default()\n)\nasync def check_api_key(api_key: str):\n    if api_key != \"valid_key\":\n        raise APIException(\n            error_code=CustomExceptionCode.INVALID_API_KEY,\n            http_status_code=401,\n        )\n    data = ApiKeyModel(api_key=\"valid_key\")\n    return ResponseModel(\n        data=data,\n        status=ExceptionStatus.SUCCESS,\n        message=\"API key is valid\",\n        description=\"The provided API key is valid.\"\n    )\n</code></pre>"},{"location":"usage/response_model/#successful-response","title":"\u2705 Successful Response","text":"<pre><code>{\n  \"data\": {\n    \"api_key\": \"valid_key\"\n  },\n  \"status\": \"SUCCESS\",\n  \"message\": \"API key is valid\",\n  \"error_code\": null,\n  \"description\": \"The provided API key is valid.\"\n}\n</code></pre>"},{"location":"usage/response_model/#error-response","title":"\u274c Error Response","text":"<pre><code>{\n  \"data\": null,\n  \"status\": \"FAIL\",\n  \"message\": \"Invalid API key.\",\n  \"error_code\": \"API-401\",\n  \"description\": \"Provide a valid API key.\"\n}\n</code></pre> <p>No matter what happens \u2014 same shape, same fields, always predictable.</p>"},{"location":"usage/response_model/#why-use-it","title":"\u26a1 Why Use It?","text":"<p>\u2714\ufe0f Frontend teams can build once and trust the schema.</p> <p>\u2714\ufe0f No more scattered response shapes across endpoints.</p> <p>\u2714\ufe0f Swagger/OpenAPI docs stay clear and self-explanatory.</p> <p>\u2714\ufe0f Debugging becomes easy with <code>description</code> and <code>error_code</code>.</p>"},{"location":"usage/response_model/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Ready to define your own error codes? Check out \ud83d\uddc2\ufe0f Custom Exception Codes</p> <p>\u2714\ufe0f Want to handle unexpected crashes globally? Learn about \ud83e\ude93 Fallback Middleware</p> <p>\u2714\ufe0f Want to see how this shows up in Swagger? Head over to \ud83d\udcda Swagger Integration</p>"}]}